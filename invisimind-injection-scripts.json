{
  "version": "1.0.0",
  "platforms": {
    "chatgpt": {
      "selectors": {
        "input": "#prompt-textarea",
        "submit": "button[data-testid=\"send-button\"]",
        "submit_alt": "button[aria-label=\"Send prompt\"]"
      },
      "scripts": {
        "inject_text": "(function() {\n                // Function to find the visible, active input field\n                function findActiveInput() {\n                    const inputs = document.querySelectorAll('#prompt-textarea');\n\n                    // If multiple inputs, find the visible one\n                    for (const input of inputs) {\n                        const rect = input.getBoundingClientRect();\n                        const style = window.getComputedStyle(input);\n\n                        // Check if element is visible and has dimensions\n                        if (rect.width > 0 && rect.height > 0 &&\n                            style.display !== 'none' &&\n                            style.visibility !== 'hidden' &&\n                            input.offsetParent !== null) {\n                            return input;\n                        }\n                    }\n\n                    // Fallback to first element if found\n                    return inputs.length > 0 ? inputs[0] : null;\n                }\n\n                const input = findActiveInput();\n                if (input) {\n                    // For ProseMirror/contenteditable, REPLACE existing text\n                    input.textContent = `{{TEXT}}`;\n\n                    // Place cursor at end\n                    const range = document.createRange();\n                    const sel = window.getSelection();\n                    range.selectNodeContents(input);\n                    range.collapse(false);\n                    sel.removeAllRanges();\n                    sel.addRange(range);\n\n                    // Dispatch events for contenteditable\n                    input.dispatchEvent(new InputEvent('input', {\n                        bubbles: true,\n                        cancelable: true,\n                        inputType: 'insertText'\n                    }));\n                    input.dispatchEvent(new Event('change', { bubbles: true }));\n                    \n                    console.log('ChatGPT text replaced successfully');\n                    return true;\n                } else {\n                    console.error('ChatGPT input not found');\n                    return false;\n                }\n            })()",
        "submit": "(function() {\n            function findVisibleSubmit() {\n                const selectors = ['button[data-testid=\"send-button\"]', 'button[aria-label=\"Send prompt\"]'];\n                for (const selector of selectors) {\n                    const btns = document.querySelectorAll(selector);\n                    for (const btn of btns) {\n                         const rect = btn.getBoundingClientRect();\n                         const style = window.getComputedStyle(btn);\n                         if (rect.width > 0 && rect.height > 0 &&\n                             style.display !== 'none' && style.visibility !== 'hidden' &&\n                             !btn.disabled) {\n                             return btn;\n                         }\n                    }\n                }\n                return null;\n            }\n\n            const btn = findVisibleSubmit();\n            if (btn) {\n                console.log('Found visible submit button, clicking...');\n                btn.click();\n            } else {\n                console.error('No visible submit button found');\n            }\n        })()",
        "append_text": "(function() {\n                // Function to find the visible, active input field\n                function findActiveInput() {\n                    const inputs = document.querySelectorAll('#prompt-textarea');\n\n                    // If multiple inputs, find the visible one\n                    for (const input of inputs) {\n                        const rect = input.getBoundingClientRect();\n                        const style = window.getComputedStyle(input);\n\n                        // Check if element is visible and has dimensions\n                        if (rect.width > 0 && rect.height > 0 &&\n                            style.display !== 'none' &&\n                            style.visibility !== 'hidden' &&\n                            input.offsetParent !== null) {\n                            return input;\n                        }\n                    }\n\n                    // Fallback to first element if found\n                    return inputs.length > 0 ? inputs[0] : null;\n                }\n\n                // Retry finding the input element (in case DOM is re-rendering)\n                let input = findActiveInput();\n\n                // If not found, try a few more times with small delays\n                if (!input) {\n                    console.warn('ChatGPT input not found on first try, will retry...');\n                    return new Promise((resolve) => {\n                        let attempts = 0;\n                        const maxAttempts = 5;\n                        const interval = setInterval(() => {\n                            input = findActiveInput();\n                            attempts++;\n\n                            if (input) {\n                                clearInterval(interval);\n                                appendText(input);\n                                resolve(true);\n                            } else if (attempts >= maxAttempts) {\n                                clearInterval(interval);\n                                console.error('ChatGPT input not found after', maxAttempts, 'attempts');\n                                resolve(false);\n                            }\n                        }, 100);\n                    });\n                }\n\n                function appendText(input) {\n                    // For ProseMirror/contenteditable, append to existing text\n                    const currentText = input.textContent || '';\n                    const newText = currentText + \"{{TEXT}}\";\n                    input.textContent = newText;\n\n                    // Place cursor at end\n                    const range = document.createRange();\n                    const sel = window.getSelection();\n                    range.selectNodeContents(input);\n                    range.collapse(false);\n                    sel.removeAllRanges();\n                    sel.addRange(range);\n\n                    // Dispatch events for contenteditable\n                    input.dispatchEvent(new InputEvent('input', {\n                        bubbles: true,\n                        cancelable: true,\n                        inputType: 'insertText'\n                    }));\n                    input.dispatchEvent(new Event('change', { bubbles: true }));\n                }\n\n                if (input) {\n                    appendText(input);\n                }\n                return true;\n            })()",
        "clear": "(function() {\n            const textarea = document.querySelector('#prompt-textarea');\n            if (textarea) {\n                textarea.value = '';\n                textarea.textContent = '';\n                textarea.dispatchEvent(new Event('input', { bubbles: true }));\n            }\n        })()",
        "click_through_enable": "(function() {\n                    // Remove existing style if it exists\n                    const existingStyle = document.getElementById('click-through-style');\n                    if (existingStyle) existingStyle.remove();\n\n                    // Create style element\n                    const style = document.createElement('style');\n                    style.id = 'click-through-style';\n                    style.textContent = `\n                        /* Make everything click-through by default */\n                        body * {\n                            pointer-events: none !important;\n                        }\n\n                        /* Enable specific interactive elements */\n                        #prompt-textarea,\n                        button[data-testid=\"send-button\"],\n                        button[aria-label=\"Send prompt\"],\n                        [role=\"textbox\"],\n                        textarea,\n                        input,\n                        /* Allow scrolling */\n                        [class*=\"scroll\"],\n                        [class*=\"overflow\"],\n                        main,\n                        .overflow-y-auto,\n                        /* Keep send button clickable */\n                        button[class*=\"absolute\"] {\n                            pointer-events: auto !important;\n                        }\n\n                        /* Ensure scrollable containers work */\n                        body {\n                            pointer-events: auto !important;\n                        }\n\n                        /* Ensure cursor remains default (system cursor will show) */\n                        * {\n                            cursor: default !important;\n                        }\n                    `;\n                    document.head.appendChild(style);\n\n                    // Store original titles and remove them\n                    document.querySelectorAll('[title]').forEach(el => {\n                        if (!el.matches('#prompt-textarea, button[data-testid=\"send-button\"]')) {\n                            el.setAttribute('data-original-title', el.getAttribute('title'));\n                            el.removeAttribute('title');\n                        }\n                    });\n\n                    console.log('Click-through mode enabled for ChatGPT');\n                })()",
        "click_through_disable": "(function() {\n                const existingStyle = document.getElementById('click-through-style');\n                if (existingStyle) {\n                    existingStyle.remove();\n                    console.log('Click-through mode disabled');\n                }\n\n                // Restore original titles\n                document.querySelectorAll('[data-original-title]').forEach(el => {\n                    el.setAttribute('title', el.getAttribute('data-original-title'));\n                    el.removeAttribute('data-original-title');\n                });\n            })()",
        "image_inject": "(async function() {\n                console.log('Injecting screenshot into ChatGPT...');\n                \n                // Find the input field\n                const input = document.querySelector('#prompt-textarea');\n                if (!input) {\n                    console.error('ChatGPT input not found');\n                    return false;\n                }\n                \n                // Convert base64 to blob\n                const base64Data = '{{BASE64_IMAGE}}';\n                const byteCharacters = atob(base64Data);\n                const byteNumbers = new Array(byteCharacters.length);\n                for (let i = 0; i < byteCharacters.length; i++) {\n                    byteNumbers[i] = byteCharacters.charCodeAt(i);\n                }\n                const byteArray = new Uint8Array(byteNumbers);\n                const blob = new Blob([byteArray], { type: 'image/png' });\n                \n                // Create a File from the blob\n                const file = new File([blob], 'screenshot.png', { type: 'image/png' });\n                \n                // Create DataTransfer and add file\n                const dataTransfer = new DataTransfer();\n                dataTransfer.items.add(file);\n                \n                // Focus the input\n                input.focus();\n                \n                // Create and dispatch paste event\n                const pasteEvent = new ClipboardEvent('paste', {\n                    bubbles: true,\n                    cancelable: true,\n                    clipboardData: dataTransfer\n                });\n                \n                input.dispatchEvent(pasteEvent);\n                console.log('Screenshot paste event dispatched');\n                \n                return true;\n            })()",
        "auto_scroll_enable": "(function() {\n                // Clear any existing auto-scroll interval\n                if (window._autoScrollInterval) {\n                    clearInterval(window._autoScrollInterval);\n                    console.log('Cleared existing auto-scroll interval');\n                }\n                \n                // Set up new auto-scroll interval (smarter scrolling)\n                window._autoScrollInterval = setInterval(() => {\n                    const container = document.querySelector('[data-scroll-root=\"true\"]');\n                    if (container) {\n                        // Only scroll if user is already near bottom (within 200px)\n                        const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 200;\n                        if (isNearBottom) {\n                            container.scrollTo({top: container.scrollHeight, behavior: 'smooth'});\n                        }\n                    }\n                }, 2000);\n                \n                console.log('Auto-scroll enabled for ChatGPT (smart mode)');\n                return true;\n            })()",
        "auto_scroll_disable": "(function() {\n                if (window._autoScrollInterval) {\n                    clearInterval(window._autoScrollInterval);\n                    window._autoScrollInterval = null;\n                    console.log('Auto-scroll disabled for ChatGPT');\n                    return true;\n                }\n                console.log('No auto-scroll interval to clear');\n                return false;\n            })()",
        "dictation_start": "(function() {\n                const btn = document.querySelector('button[aria-label*=\"dictate\"].composer-btn, button[aria-label*=\"Dictate\"].composer-btn');\n                if (btn) {\n                    console.log('Found dictation button, clicking...');\n                    btn.click();\n                    return true;\n                } else {\n                    console.error('Dictation button not found');\n                    return false;\n                }\n            })()",
        "dictation_submit": "(function() {\n                const btn = document.querySelector('button[aria-label*=\"submit dictation\"].composer-btn, button[aria-label*=\"Submit dictation\"].composer-btn');\n                if (btn) {\n                    console.log('Found submit dictation button, clicking...');\n                    btn.click();\n                    return true;\n                } else {\n                    console.error('Submit dictation button not found');\n                    return false;\n                }\n            })()"
      }
    },
    "gemini": {
      "selectors": {
        "input": "rich-textarea .ql-editor, div[contenteditable=\"true\"]",
        "submit": "button[aria-label=\"Send message\"]"
      },
      "scripts": {
        "inject_text": "(function() {\n                const editor = document.querySelector('rich-textarea .ql-editor, div[contenteditable=\"true\"]');\n                if (editor) {\n                    // For contenteditable, REPLACE existing text\n                    editor.textContent = `{{TEXT}}`;\n\n                    // Place cursor at end\n                    const range = document.createRange();\n                    const sel = window.getSelection();\n                    range.selectNodeContents(editor);\n                    range.collapse(false);\n                    sel.removeAllRanges();\n                    sel.addRange(range);\n\n                    // Dispatch proper events for contenteditable\n                    editor.dispatchEvent(new InputEvent('input', {\n                        bubbles: true,\n                        cancelable: true,\n                        inputType: 'insertText'\n                    }));\n                    editor.dispatchEvent(new Event('change', { bubbles: true }));\n\n                    console.log('Gemini text replaced successfully');\n                    return true;\n                } else {\n                    console.error('Gemini input not found');\n                    return false;\n                }\n            })()",
        "submit": "(function() {\n            const btn = document.querySelector('button[aria-label=\"Send message\"]');\n            if (btn) btn.click();\n        })()",
        "append_text": "(function() {\n                const input = document.querySelector('rich-textarea .ql-editor, div[contenteditable=\"true\"]');\n                if (input) {\n                    const currentText = input.textContent || '';\n                    input.textContent = currentText + \"{{TEXT}}\";\n                    input.dispatchEvent(new Event('input', { bubbles: true }));\n                    return true;\n                }\n                return false;\n            })()",
        "clear": "(function() {\n            const editor = document.querySelector('rich-textarea .ql-editor, div[contenteditable=\"true\"]');\n            if (editor) {\n                editor.innerText = '';\n                editor.textContent = '';\n                editor.dispatchEvent(new Event('input', { bubbles: true }));\n            }\n        })()",
        "click_through_enable": "(function() {\n                    const existingStyle = document.getElementById('click-through-style');\n                    if (existingStyle) existingStyle.remove();\n\n                    const style = document.createElement('style');\n                    style.id = 'click-through-style';\n                    style.textContent = `\n                        body * {\n                            pointer-events: none !important;\n                        }\n\n                        rich-textarea,\n                        rich-textarea *,\n                        .ql-editor,\n                        button[aria-label=\"Send message\"],\n                        [contenteditable=\"true\"],\n                        textarea,\n                        input,\n                        [class*=\"scroll\"],\n                        main,\n                        body {\n                            pointer-events: auto !important;\n                        }\n\n                        /* Ensure cursor remains default (system cursor will show) */\n                        * {\n                            cursor: default !important;\n                        }\n                    `;\n                    document.head.appendChild(style);\n\n                    // Store original titles and remove them\n                    document.querySelectorAll('[title]').forEach(el => {\n                        if (!el.matches('rich-textarea, .ql-editor, button[aria-label=\"Send message\"]')) {\n                            el.setAttribute('data-original-title', el.getAttribute('title'));\n                            el.removeAttribute('title');\n                        }\n                    });\n\n                    console.log('Click-through mode enabled for Gemini');\n                })()",
        "click_through_disable": "(function() {\n                const existingStyle = document.getElementById('click-through-style');\n                if (existingStyle) {\n                    existingStyle.remove();\n                    console.log('Click-through mode disabled');\n                }\n\n                // Restore original titles\n                document.querySelectorAll('[data-original-title]').forEach(el => {\n                    el.setAttribute('title', el.getAttribute('data-original-title'));\n                    el.removeAttribute('data-original-title');\n                });\n            })()",
        "image_inject": "(async function() {\n                console.log('Injecting screenshot into Gemini...');\n                \n                // Find the input field\n                const input = document.querySelector('rich-textarea .ql-editor, div[contenteditable=\"true\"]');\n                if (!input) {\n                    console.error('Gemini input not found');\n                    return false;\n                }\n                \n                // Convert base64 to blob\n                const base64Data = '{{BASE64_IMAGE}}';\n                const byteCharacters = atob(base64Data);\n                const byteNumbers = new Array(byteCharacters.length);\n                for (let i = 0; i < byteCharacters.length; i++) {\n                    byteNumbers[i] = byteCharacters.charCodeAt(i);\n                }\n                const byteArray = new Uint8Array(byteNumbers);\n                const blob = new Blob([byteArray], { type: 'image/png' });\n                \n                // Create a File from the blob\n                const file = new File([blob], 'screenshot.png', { type: 'image/png' });\n                \n                // Create DataTransfer and add file\n                const dataTransfer = new DataTransfer();\n                dataTransfer.items.add(file);\n                \n                // Focus and dispatch paste event\n                input.focus();\n                \n                const pasteEvent = new ClipboardEvent('paste', {\n                    bubbles: true,\n                    cancelable: true,\n                    clipboardData: dataTransfer\n                });\n                \n                input.dispatchEvent(pasteEvent);\n                console.log('Screenshot paste event dispatched');\n                return true;\n            })()",
        "auto_scroll_enable": "(function() {\n                // Clear any existing auto-scroll interval\n                if (window._autoScrollInterval) {\n                    clearInterval(window._autoScrollInterval);\n                    console.log('Cleared existing auto-scroll interval');\n                }\n                \n                // Set up new auto-scroll interval (smarter scrolling)\n                window._autoScrollInterval = setInterval(() => {\n                    const container = document.querySelector('chat-window-content #chat-history infinite-scroller');\n                    if (container) {\n                        // Only scroll if user is already near bottom (within 200px)\n                        const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 200;\n                        if (isNearBottom) {\n                            container.scrollTo({top: container.scrollHeight, behavior: 'smooth'});\n                        }\n                    }\n                }, 2000);\n                \n                console.log('Auto-scroll enabled for Gemini (smart mode)');\n                return true;\n            })()",
        "auto_scroll_disable": "(function() {\n                if (window._autoScrollInterval) {\n                    clearInterval(window._autoScrollInterval);\n                    window._autoScrollInterval = null;\n                    console.log('Auto-scroll disabled for Gemini');\n                    return true;\n                }\n                console.log('No auto-scroll interval to clear');\n                return false;\n            })()"
      }
    },
    "claude": {
      "selectors": {
        "input": "div.ProseMirror[contenteditable=\"true\"]",
        "submit": "button[aria-label=\"Send message\"]",
        "submit_alt": "button[aria-label=\"Send Message\"]"
      },
      "scripts": {
        "inject_text": "(function() {\n                const editor = document.querySelector('div.ProseMirror[contenteditable=\"true\"]');\n                if (editor) {\n                    // For ProseMirror contenteditable, REPLACE existing text\n                    editor.textContent = `{{TEXT}}`;\n\n                    // Place cursor at end\n                    const range = document.createRange();\n                    const sel = window.getSelection();\n                    range.selectNodeContents(editor);\n                    range.collapse(false);\n                    sel.removeAllRanges();\n                    sel.addRange(range);\n\n                    // Dispatch proper events for ProseMirror\n                    editor.dispatchEvent(new InputEvent('input', {\n                        bubbles: true,\n                        cancelable: true,\n                        inputType: 'insertText'\n                    }));\n                    editor.dispatchEvent(new Event('change', { bubbles: true }));\n\n                    console.log('Claude text replaced successfully');\n                    return true;\n                } else {\n                    console.error('Claude input not found');\n                    return false;\n                }\n            })()",
        "submit": "(function() {\n            const btn = document.querySelector('button[aria-label=\"Send message\"]');\n            if (btn) btn.click();\n        })()",
        "append_text": "(function() {\n                const input = document.querySelector('div.ProseMirror[contenteditable=\"true\"]');\n                if (input) {\n                    const currentText = input.textContent || '';\n                    input.textContent = currentText + \"{{TEXT}}\";\n                    input.dispatchEvent(new Event('input', { bubbles: true }));\n                    return true;\n                }\n                return false;\n            })()",
        "clear": "(function() {\n            const editor = document.querySelector('div.ProseMirror[contenteditable=\"true\"]');\n            if (editor) {\n                editor.innerText = '';\n                editor.textContent = '';\n                editor.dispatchEvent(new Event('input', { bubbles: true }));\n            }\n        })()",
        "click_through_enable": "(function() {\n                    const existingStyle = document.getElementById('click-through-style');\n                    if (existingStyle) existingStyle.remove();\n\n                    const style = document.createElement('style');\n                    style.id = 'click-through-style';\n                    style.textContent = `\n                        body * {\n                            pointer-events: none !important;\n                        }\n\n                        div.ProseMirror,\n                        div.ProseMirror *,\n                        button[aria-label=\"Send message\"],\n                        button[aria-label=\"Send Message\"],\n                        [contenteditable=\"true\"],\n                        textarea,\n                        input,\n                        [class*=\"scroll\"],\n                        [class*=\"overflow\"],\n                        main,\n                        body {\n                            pointer-events: auto !important;\n                        }\n\n                        /* Ensure cursor remains default (system cursor will show) */\n                        * {\n                            cursor: default !important;\n                        }\n                    `;\n                    document.head.appendChild(style);\n\n                    // Store original titles and remove them\n                    document.querySelectorAll('[title]').forEach(el => {\n                        if (!el.matches('div.ProseMirror, button[aria-label*=\"Send\"]')) {\n                            el.setAttribute('data-original-title', el.getAttribute('title'));\n                            el.removeAttribute('title');\n                        }\n                    });\n\n                    console.log('Click-through mode enabled for Claude');\n                })()",
        "click_through_disable": "(function() {\n                const existingStyle = document.getElementById('click-through-style');\n                if (existingStyle) {\n                    existingStyle.remove();\n                    console.log('Click-through mode disabled');\n                }\n\n                // Restore original titles\n                document.querySelectorAll('[data-original-title]').forEach(el => {\n                    el.setAttribute('title', el.getAttribute('data-original-title'));\n                    el.removeAttribute('data-original-title');\n                });\n            })()",
        "image_inject": "(async function() {\n                console.log('Injecting screenshot into Claude...');\n                \n                // Find the input field\n                const input = document.querySelector('div.ProseMirror[contenteditable=\"true\"]');\n                if (!input) {\n                    console.error('Claude input not found');\n                    return false;\n                }\n                \n                // Convert base64 to blob\n                const base64Data = '{{BASE64_IMAGE}}';\n                const byteCharacters = atob(base64Data);\n                const byteNumbers = new Array(byteCharacters.length);\n                for (let i = 0; i < byteCharacters.length; i++) {\n                    byteNumbers[i] = byteCharacters.charCodeAt(i);\n                }\n                const byteArray = new Uint8Array(byteNumbers);\n                const blob = new Blob([byteArray], { type: 'image/png' });\n                \n                // Create a File from the blob\n                const file = new File([blob], 'screenshot.png', { type: 'image/png' });\n                \n                // Create DataTransfer and add file\n                const dataTransfer = new DataTransfer();\n                dataTransfer.items.add(file);\n                \n                // Focus and dispatch paste event\n                input.focus();\n                \n                const pasteEvent = new ClipboardEvent('paste', {\n                    bubbles: true,\n                    cancelable: true,\n                    clipboardData: dataTransfer\n                });\n                \n                input.dispatchEvent(pasteEvent);\n                console.log('Screenshot paste event dispatched');\n                return true;\n            })()",
        "auto_scroll_enable": "(function() {\n                // Clear any existing auto-scroll interval\n                if (window._autoScrollInterval) {\n                    clearInterval(window._autoScrollInterval);\n                    console.log('Cleared existing auto-scroll interval');\n                }\n                \n                // Set up new auto-scroll interval (smarter scrolling)\n                window._autoScrollInterval = setInterval(() => {\n                    const container = document.querySelector('#main-content .overflow-y-scroll.overflow-x-hidden');\n                    if (container) {\n                        // Only scroll if user is already near bottom (within 200px)\n                        const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 200;\n                        if (isNearBottom) {\n                            container.scrollTo({top: container.scrollHeight, behavior: 'smooth'});\n                        }\n                    }\n                }, 2000);\n                \n                console.log('Auto-scroll enabled for Claude (smart mode)');\n                return true;\n            })()",
        "auto_scroll_disable": "(function() {\n                if (window._autoScrollInterval) {\n                    clearInterval(window._autoScrollInterval);\n                    window._autoScrollInterval = null;\n                    console.log('Auto-scroll disabled for Claude');\n                    return true;\n                }\n                console.log('No auto-scroll interval to clear');\n                return false;\n            })()"
      }
    }
  }
}
